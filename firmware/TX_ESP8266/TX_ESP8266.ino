// ESP8266 HUD duplo lendo NANO_TX por UART (115200)
// INT: SCL=D5, SDA=D6, U8G2_R0  (C1..C4 com bolinha C5..C8)
// EXT: SCL=D1, SDA=D2, U8G2_R2  (idem) + S1/S2/CAL
// Buzzer ativo 3V3: D7 (GPIO13) - bipes em trocas de modo (CAL<->NORMAL)
// Animação CAL: ponto girando em círculo (overlay leve)

#include <Arduino.h>
#include <U8g2lib.h>
#include <stdint.h>

// --- corrige o autoprotótipo do Arduino ---
struct BuzzPat;                 // forward declaration do tipo
void startBuzz(const BuzzPat&); // protótipo manual (bloqueia o autoproto)


// -------- Logo (128x64) --------
const unsigned char myLogo [1024] PROGMEM = {
  // 'myLogo, 128x64px
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x3f, 0xfc, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x3f, 0xfc, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x3f, 0xfc, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x3f, 0xfc, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x3e, 0x7c, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x3c, 0x1c, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x30, 0x0c, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x01, 0x80, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x07, 0xe0, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x1f, 0xf8, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x3f, 0xfc, 0x3f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0xff, 0xff, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xc0, 0x03, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x01, 0x80, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x07, 0xe0, 0x3f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x1f, 0xf8, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xe0, 0x3f, 0xfc, 0x03, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0xff, 0xff, 0x01, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x03, 0xff, 0xff, 0xc0, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x0f, 0xff, 0xff, 0xf0, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x3f, 0xff, 0xff, 0xfc, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0x01, 0xff, 0xff, 0xff, 0xff, 0x80, 0xf0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x07, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x07, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0e, 0x07, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x08, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x10, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
#define LOGO_WIDTH  128
#define LOGO_HEIGHT 64
#define BUZZER_PIN D7

// -------- Displays --------
U8G2_SSD1306_128X64_NONAME_F_SW_I2C oledInt(
  U8G2_R2, /*clock=*/D5, /*data=*/D6, /*reset=*/U8X8_PIN_NONE
);
U8G2_SSD1306_128X64_NONAME_F_SW_I2C oledExt(
  U8G2_R2, /*clock=*/D1, /*data=*/D2, /*reset=*/U8X8_PIN_NONE
);
k
// -------- Payload UART --------
struct __attribute__((packed)) Payload {
  uint8_t ch[8];       // 0..255
  uint8_t sw;          // bit0=S1, bit1=S2, bit2=CAL
  uint8_t rfu0, rfu1;  // 0
};

static uint8_t crc8(const uint8_t* d, size_t n){
  uint8_t c=0x00;
  for(size_t i=0;i<n;i++){
    uint8_t x=d[i];
    for(uint8_t b=0;b<8;b++){ uint8_t mix=(c^x)&1; c>>=1; if(mix) c^=0x8C; x>>=1; }
  }
  return c;
}

bool readFrame(HardwareSerial &S, Payload &out){
  enum {S1,S2,SL,SP,SC};
  static uint8_t st=S1, len=0, buf[32], idx=0;
  while (S.available()){
    uint8_t b = S.read();
    switch(st){
      case S1: st=(b==0xAA)?S2:S1; break;
      case S2: st=(b==0x55)?SL:S1; break;
      case SL: len=b; if(len>sizeof(buf)){ st=S1; break; } idx=0; st=SP; break;
      case SP: buf[idx++]=b; if(idx>=len) st=SC; break;
      case SC:{
        uint8_t c=crc8(buf,len);
        bool ok=(c==b && len==sizeof(Payload));
        st=S1;
        if (ok){ memcpy(&out,buf,sizeof(Payload)); return true; }
        return false;
      }
    }
  }
  return false;
}

// -------- Helpers de desenho --------
static inline uint8_t barW(uint8_t v, uint8_t w){ return (uint16_t(v)*(w-2)+127)/255; }

// -------- Buzzer (não-bloqueante) --------
enum BuzzState { BZ_IDLE, BZ_ON, BZ_OFF };

// ✅ defina o tipo AQUI, antes de qualquer uso
struct BuzzPat {
  uint16_t onMs;
  uint16_t offMs;
  uint8_t  reps;
};

// (agora as variáveis)
BuzzState bzState = BZ_IDLE;
uint32_t  bzT0 = 0;
uint8_t   bzLeft = 0;
uint16_t  bzOnMs=0, bzOffMs=0;

// (e só depois as funções que usam BuzzPat)
void startBuzz(const BuzzPat &p){
  bzOnMs = p.onMs;
  bzOffMs = p.offMs;
  bzLeft = p.reps * 2;   // ON+OFF = 2 steps
  bzState = BZ_ON;
  bzT0 = millis();
  digitalWrite(BUZZER_PIN, HIGH);
}


void buzzerTask(){
  if (bzState==BZ_IDLE || bzLeft==0) return;
  uint32_t dt = millis() - bzT0;
  if (bzState==BZ_ON && dt >= bzOnMs){
    digitalWrite(BUZZER_PIN, LOW);
    bzState = BZ_OFF; bzT0 = millis(); bzLeft--;
  } else if (bzState==BZ_OFF && dt >= bzOffMs){
    if (bzLeft>1){
      digitalWrite(BUZZER_PIN, HIGH);
      bzState = BZ_ON;  bzT0 = millis(); bzLeft--;
    } else {
      bzState = BZ_IDLE; bzLeft = 0; digitalWrite(BUZZER_PIN, LOW);
    }
  }
}

const BuzzPat BZ_EXIT  = {120, 120, 2};  // bi-bi
const BuzzPat BZ_ENTER = {350, 120, 1};  // biiii

// -------- Animação CAL (ponto girando) --------
const int8_t CIRC_X[16] = { 0, 3, 6, 8,  9,  8,  6, 3,  0, -3, -6, -8, -9, -8, -6, -3 };
const int8_t CIRC_Y[16] = {-9,-8,-6,-3,  0,  3,  6, 8,  9,  8,  6,  3,  0, -3, -6, -8 };

void drawCalOverlay(U8G2 &d){
  static uint8_t step=0;
  step = (millis()/60) & 0x0F; // ~16 fps
  int cx = 64, cy = 32;
  d.drawCircle(cx, cy, 11, U8G2_DRAW_ALL);
  d.drawDisc  (cx + CIRC_X[step], cy + CIRC_Y[step], 2, U8G2_DRAW_ALL);
}

// -------- Telas --------
void drawIntegrated(U8G2 &d, const Payload& p, bool linkOk, bool cal){
  d.clearBuffer();
  d.setFont(u8g2_font_6x10_tf);
  d.drawStr(0,10,"INT C1..C4 + dot C5..C8");
  d.drawStr(94,10, linkOk ? "LINK" : "----");

  const int w = 60, h = 10, dx = 64, dy = 22;
  for(int i=0;i<4;i++){
    int col = i/2, row = i%2;
    int x = 4 + col*dx;
    int y = 16 + row*dy;
    d.drawFrame(x,y,w,h);
    uint8_t bw = barW(p.ch[i], w);
    d.drawBox(x+1, y+1, bw, h-2);

    uint8_t bx = x+1 + barW(p.ch[4+i], w);
    int cy = y + h/2;
    d.drawDisc(bx, cy, 2, U8G2_DRAW_ALL);

    d.setCursor(x, y+h+10);
    d.print('C'); d.print(i+1); d.print('/'); d.print(i+5);
    d.print(" v="); d.print((int)p.ch[i]);
  }

  if (cal){
    drawCalOverlay(d);
    d.setCursor(98, 24); d.print("CAL");
  }
  d.sendBuffer();
}

void drawExternal(U8G2 &d, const Payload& p, bool linkOk, bool cal){
  d.clearBuffer();
  d.setFont(u8g2_font_6x10_tf);
  d.drawStr(94,10, linkOk ? "LINK" : "----");

  const int w = 60, h = 10, dx = 64, dy = 22;
  for(int i=0;i<4;i++){
    int col = i/2, row = i%2;
    int x = 4 + col*dx;
    int y = 16 + row*dy;
    d.drawFrame(x,y,w,h);
    uint8_t bw = barW(p.ch[i], w);
    d.drawBox(x+1, y+1, bw, h-2);

    uint8_t bx = x+1 + barW(p.ch[4+i], w);
    int cy = y + h/2;
    d.drawDisc(bx, cy, 2, U8G2_DRAW_ALL);
  }

  // S1/S2/CAL destaque
  d.setFont(u8g2_font_7x14B_tf);
  d.drawStr(4, 62,  (p.sw&1)?"ON ":"OFF");
  d.drawStr(68,62,  (p.sw&2)?"ON ":"OFF");

  if (cal) drawCalOverlay(d);
  d.sendBuffer();
}

// -------- Estado --------
Payload cur{}, prev{};
uint32_t tLastRx=0;
bool calPrev=false;

static bool payloadChanged(const Payload& a, const Payload& b){
  if (a.sw != b.sw) return true;
  for (int i=0;i<8;i++) if (a.ch[i]!=b.ch[i]) return true;
  return false;
}

void bootSplash(uint16_t total_ms = 2000) {
  const int cx = (128 - LOGO_WIDTH)  / 2;
  const int cy = (64  - LOGO_HEIGHT) / 2;

  const int BAR_X = 8, BAR_W = 112, BAR_H = 8, BAR_Y = 64 - 10;

  uint32_t t0 = millis();
  while (true) {
    uint32_t elapsed = millis() - t0;
    if (elapsed > total_ms) elapsed = total_ms;
    uint16_t fill = (uint32_t)elapsed * (BAR_W - 2) / total_ms;

    oledInt.clearBuffer();
    oledInt.drawXBMP(cx, cy, LOGO_WIDTH, LOGO_HEIGHT, myLogo);
    oledInt.drawFrame(BAR_X, BAR_Y, BAR_W, BAR_H);
    oledInt.drawBox(BAR_X + 1, BAR_Y + 1, fill, BAR_H - 2);
    oledInt.sendBuffer();

    oledExt.clearBuffer();
    oledExt.drawXBMP(cx, cy, LOGO_WIDTH, LOGO_HEIGHT, myLogo);
    oledExt.drawFrame(BAR_X, BAR_Y, BAR_W, BAR_H);
    oledExt.drawBox(BAR_X + 1, BAR_Y + 1, fill, BAR_H - 2);
    oledExt.sendBuffer();

    if (elapsed >= total_ms) break;
    delay(16);
    yield();
  }
}

void setup(){
  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, LOW);

  // UART0 padrão: RX=GPIO3, TX=GPIO1 (NÃO usar Serial.swap())
  Serial.begin(115200);

  oledInt.begin();
  oledExt.begin();

  oledInt.clearBuffer(); oledInt.setFont(u8g2_font_6x10_tf);
  oledInt.drawStr(0,12,"INT (D5/D6) R0"); oledInt.sendBuffer();

  oledExt.clearBuffer(); oledExt.setFont(u8g2_font_6x10_tf);
  oledExt.drawStr(0,12,"EXT (D1/D2) R2"); oledExt.sendBuffer();

  bootSplash(2000);
  delay(100);
}

void loop(){
  bool got = readFrame(Serial, cur);
  if (got) tLastRx = millis();

  // Buzzer em trocas de modo CAL
  bool calNow = (cur.sw & 0x04);
  if (calNow != calPrev){
    if (calNow) startBuzz(BZ_ENTER); else startBuzz(BZ_EXIT);
    calPrev = calNow;
  }
  buzzerTask();

  // Nano transmite ~a cada 25 ms; 300 ms é margem segura para "link ok"
  bool linkOk = (millis() - tLastRx) < 300;

  static uint32_t tDraw=0;
  bool needDraw = got || payloadChanged(cur, prev) || (millis()-tDraw)>=33; // ~30 FPS

  if (needDraw){
    tDraw = millis();
    drawIntegrated(oledInt, cur, linkOk, calNow);
    drawExternal  (oledExt, cur, linkOk, calNow);
    prev = cur;
  }
}
